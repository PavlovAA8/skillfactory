from typing import Callable
flag_live = True	# Переменная отвечающая за постоянно работающую консоль
rules = "Правила игры\n1. Первыми начинают ход Х.\n2. Координаты постановки символа вводятся в диапазоне от 0 до 2 (включительно) через пробел.\nПервая координата отвечает за ось x (столбец), вторая - за ось y (строка).\n"	# Переменная содержит текст правил игры
area = [[" ", "0", "1", "2"],
	["0", "-", "-", "-",],
	["1", "-", "-", "-",],
	["2", "-", "-", "-",]]	# Игровое поле типа Список
area_turn = ("x", "o", "x", "o", "x", "o", "x", "o", "x")	# Переменная типа Кортеж содержит очередность ходов игры
coordinates = (0, 1, 2) # Переменная типа Кортеж содержит допустимые значения координат которые вводят игроки (ограничения для ввода)

def print_area():
	"""
	Вывод игрового поля в консоль.
	
	Каждый элемент списка выводится в консоль с новой строки образуя игровое поле.
	"""
	for i in area:
		print(*i)
	print()

def input_coord(x: str = "", y: str = "") -> list:
	"""
	Ввод координат постановки символа в игровое поле.

	x - принимает значение координаты столбца введенное с клавиатуры.
	Пока введенное значение не цифра или не входит в кортеж с допустимыми значениям, запускается повторный вывод координаты.
	y - принимает значение координаты строки введенное с клавиатуры.
	Пока введенное значение не цифра или не входит в кортеж с допустимыми значениям, запускается повторный вывод координаты.
	Далее введенным координатам прибавляется 1, чтобы исключить первую строку и столбец ("0", "1", "2") списка с игровым полем.
	Выполняется проверка элемента с заданными координатами, если элемент не равен стандартному значению, то функция ввода координат запускается заново.
	Иначе же функция возвращает введенные координаты.
	"""
	x = input("Введите координату Х: ")
	while (not x.isdigit()) or (x not in tuple(map(str, coordinates))):
		print("Неверно введена координата Х. Попробуйте ввести еще раз.")
		x = input("Введите координату Х: ")
	y = input("Введите координату Y: ")
	while (not y.isdigit()) or (y not in tuple(map(str, coordinates))):
		print("Неверно введена координата Y. Попробуйте ввести еще раз.")
		y = input("Введите координату Y: ")

	x, y = int(x) + 1, int(y) + 1
	if area[y][x] != "-":
		print("Клетка занята. Выберите другие координаты.")
		return input_coord()
	else:
		return x, y

def game_over(champ: str):
	"""
	Вывод победителя.

	Если победная комбинация образовалась раньше Ничьей, то вызывается данная функция с выводом победного символа.
	"""
	print(f"Игра окончена, {champ} победили")
	print()

def start_game(area_turn: tuple) -> Callable | str:
	"""
	Игровой процесс

	Первым делом в консоль выводится игровое поле с текущими значениями.
	Выполняется проверка каждой строки на наличие одинаковых значений (все значения должны быть одинаковые), исключаем символ "по умолчанию". Если условие вовзращает положительный результат, то выполняется функция game_over.
	Выполняется проверка каждого столбца на наличие одинаковых значений (все значения должны быть одинаковые), исключаем символ "по умолчанию". Если условие вовзращает положительный результат, то выполняется функция game_over.
	Создается список для хранения элементов диагонали.
	Из каждой строки слева направо берется символ диагонали и добавляется в список diag_list. Выполняется проверка что в списке все значения одинаковые, исключаем символ "по умолчанию". Если условие вовзращает положительный результат, то выполняется функция game_over.
	Список diag_list очищается от прежнего результата.
	Создается счетчик перебора строк counter_r_l_diag.
	Из каждой строки справа налево берется символ диагонали и добавляется в список diag_list. Выполняется проверка что в списке все значения одинаковые, исключаем символ "по умолчанию". Если условие вовзращает положительный результат, то выполняется функция game_over.
	Список diag_list очищается от прежнего результата.
	Выполняется проверка на количество оставшихся ходов. Если 0, то выводится "Ничья"
	В x и y передаются значения координат введенные пользователем.
	В выбранный элемент передается символ игрока который делал ход.
	Если условия выхода из функции не были отработаны - вызывается рекурсивная функция с уменьшением кортежа с очередностью ходов.

	"""

	print_area() # Вывод игрового поля в консоль
	for row in area[1:]: # Для каждой строки игрового поля (кроме первой строки)
		if all(x != "-" and x == row[1] for x in row[1:]):	# Выполняется проверка на равенство значений и неравенство значению "по умолчанию"
			return game_over(row[1]) # Если условию выполнено, то выполняется функция game_over
	for column in zip(*area[1:]): # Для каждого столбца игрового поля (кроме первого столбца)
		if all(x != "-" and x == column[0] for x in column): # Выполняется проверка на равенство значений и неравенство значению "по умолчанию"
				return game_over(column[0]) # Если условию выполнено, то выполняется функция game_over
	
	diag_list = [] # Создается пустой список
	for l_r_diag in range(len(area))[1:]: # Счетчик на основе длины спсика игрового поля
		diag_list.append(area[l_r_diag][l_r_diag]) # Добавление значения ячейки в список diag_list
	if all(x != "-" and x == diag_list[0] for x in diag_list): # Выполняется проверка на равенство значений и неравенство значению "по умолчанию"
			return game_over(diag_list[0]) # Если условию выполнено, то выполняется функция game_over			
	diag_list.clear() # Очистка списка diag_list 

	counter_r_l_diag = 1 # Счетчик для перебора элемента по диагонали
	for r_l_diag in range(1, len(area))[::-1]: # Реверсивный счетчик на основе длины спсика игрового поля
		diag_list.append(area[counter_r_l_diag][r_l_diag]) # Добавление значения ячейки в список diag_list
		counter_r_l_diag += 1 # Повышение счетчика
	if all(x != "-" and x == diag_list[0] for x in diag_list): # Выполняется проверка на равенство значений и неравенство значению "по умолчанию"
			return game_over(diag_list[0]) # Если условию выполнено, то выполняется функция game_over
	diag_list.clear() # Очистка списка diag_list 

	if len(area_turn) == 0: # Если кортеж с очередью пуст, то в консоль выводится "Ничья"
		print("Ничья")
		print()
		return 
	
	print(f"Ход принадлежит {area_turn[0]}.") # Вывод текущего хода
	x, y = input_coord() # В x и y передаются 
	area[y][x] = area_turn[0] # Ячейка игорового поля заполняется символом текущего игрока
	return start_game(area_turn[1:]) # Вызов рекурсивной функции
	
def clean():
	"""
	Очистка игрового поля.

	Каждому элементы игрового поля задаем первоначальное значение.
	"""
	for i in range(1, len(area)):
		for j in range(1, len(area[i])):
			area[i][j] = "-"

while flag_live:	# Цикл для постоянной работы консоли
	print("""Меню\nВыберите действие:\n1 - Вывести игровое поле\n2 - Правила игры\n3 - Начать игру\n4 - Выйти\n""") # Вывод меню игры в консоль.
	player_choice = input("Ваша команда: ")	  # Переменная принимает выбранный пункт меню от пользователя с клавиатуры.
	print()
	if player_choice == "1":	# Если команда равна 1, то выполняется функция выводящая в консоль текущее игровое поле.
		print_area()
	elif player_choice == "2":	# Если команда равна 2, то в консоль выводятся правила игры.
		print(rules)
	elif player_choice == "3":	# Если команда равна 3, то выполняется функция по сбрасыванию игрового поля до первоначальных значений. Выполняется функцию старта игры.
		clean()
		start_game(area_turn)
	elif player_choice == "4":	# Если команда равна 4, то игра завершается закрытием консоли.
		flag_live = False
	else:
		print("Введена некорректная команда, повторите попытку.") # Защита от некорректного ввода команды. При неверном выборе цикл выбора пункта меню начинается заново.
		continue